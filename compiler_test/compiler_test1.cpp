// Simple test to check performance of code generated by different compilers
// The SUBLEQ code is adapted from https://rosettacode.org/wiki/Subleq#C
//
// Compile on Linux with:
// g++ -O3 compiler_test1.cpp -o compiler_test1
//
// Compile on Windows with Visual Studio with:
// cl /O2 compiler_test1.cpp
//

#include <stdio.h>
#include <time.h>

#include "subleq.h"

// Yeah, yeah, I know globals, blah, blah
const char *subleq_program = SUBLEQ_PROGRAM;
int dataSet[65535];

// This is the standard code adapted from https://rosettacode.org/wiki/Subleq#C
void subleq(int *code) {
  int ip = 0, a, b, c, nextIP;
  char ch;

  while (0 <= ip) {
    nextIP = ip + 3;
    a = code[ip];
    b = code[ip + 1];
    c = code[ip + 2];

    if (a == -1) {
      if (scanf("%c", &ch) != EOF)
        code[b] = (int)ch;
    } else if (b == -1) {
      printf("%c", (char)code[a]);
    } else {
      code[b] -= code[a];
      if (code[b] <= 0)
        nextIP = c;
    }
    ip = nextIP;
  }
}

// This is an "optimized" version which uses pointers
void subleq3() {
  int ip = 0, a, b, c;
  char ch;
  int *ds = dataSet;
  int *p = dataSet, *temp_p, *p_a, *p_b, *p_d;

  while (dataSet <= p) {
    temp_p = p + 3;
    p_a = p++;
    a = *p_a;
    p_b = p++;
    b = *p_b;
    c = *p++;

    if (a == -1) {
      if (scanf("%c", &ch) != EOF)
        *(p + b) = (int)ch;
    } else if (b == -1) {
      p_d = ds + a;
      ch = (char)*p_d;
      printf("%c", ch);
    } else {
      dataSet[b] -= dataSet[a];
      if (dataSet[b] <= 0)
        temp_p = dataSet + c;
    }
    p = temp_p;
  }
}

// Here is another "optimized" version
// But if you look carefull the pointers ipp and nextIPp
// are NOT actually used
void subleq_g3(int *code) {
  int ip = 0, nextIP;
  int a, b, c;
  char ch;
  int *ipp = code;
  int *nextIPp;
  int *temp_p;

  while (0 <= ip) {
    nextIP = ip + 3;
    temp_p = ipp;
    nextIPp = ++temp_p;
    nextIPp = ++temp_p;
    nextIPp = ++temp_p;

    a = code[ip];
    b = code[ip + 1];
    c = code[ip + 2];

    if (a == -1) {
      if (scanf("%c", &ch) != EOF)
        code[b] = (int)ch;
    } else if (b == -1) {
       printf("%c",(char)code[a]);
    } else {
      code[b] -= code[a];
      if (code[b] <= 0)
      {
        nextIP = c;
        nextIPp = code + c;
      }
    }
    ipp = nextIPp;
    ip = nextIP;
  }
}

void process_subleq_program() {
  int i, bytesread;
  const char *p = subleq_program;
  clock_t start, stop;

  i = 0;
  while (sscanf(p, "%d%n", &dataSet[i], &bytesread) > 0) {
    p += bytesread;
    i++;
  }

  // Call the original subleq code
  start = clock();
  subleq(dataSet);
  stop = clock();
  printf("subleq() took %2.2fs\n",
         (float)(stop - start) / (float)CLOCKS_PER_SEC);

  // Call the "optimzied" version
  start = clock();
  subleq3();
  stop = clock();
  printf("subleq3() took %2.2fs\n",
         (float)(stop - start) / (float)CLOCKS_PER_SEC);

  // Call the false "optimzied" version
  start = clock();
  subleq_g3(dataSet);
  stop = clock();
  printf("subleq_g3() took %2.2fs\n",
         (float)(stop - start) / (float)CLOCKS_PER_SEC);
}

int main() {
  process_subleq_program();
  return 0;
}